#### [264. 丑数 II](https://leetcode-cn.com/problems/ugly-number-ii/)

难度中等887

给你一个整数 `n` ，请你找出并返回第 `n` 个 **丑数** 。

**丑数** 就是只包含质因数 `2`、`3` 和/或 `5` 的正整数。

 

**示例 1：**

```
输入：n = 10
输出：12
解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。
```

三个指针p2，p3，p5，实际上pi的含义就是**有资格同i相乘的最小丑数的位置**。这里资格指的是：如果一个丑数nums[pi]通过乘以i可以得到下一个丑数，那么这个丑数nums[pi]就永远失去了同i相乘的资格，因为已经乘完了！我们把pi++让nums[pi]指向下一个丑数即可。

不懂的话举例说明：

一开始，丑数只有{1}，1可以同2，3，5相乘，取最小的1×2=2添加到丑数序列中。

现在丑数中有{1，2}，在上一步中，1已经同2相乘过了，所以今后没必要再比较1×2了，我们说1失去了同2相乘的资格。

现在1有与3，5相乘的资格，2有与2，3，5相乘的资格，但是2×3和2×5是没必要比较的，因为有比它更小的1可以同3，5相乘，所以我们只需要比较1×3，1×5，2×2。

依此类推，每次我们都分别比较有资格同2，3，5相乘的最小丑数，选择最小的那个作为下一个丑数，假设选择到的这个丑数是同i（i=2，3，5）相乘得到的，所以它失去了同i相乘的资格，把对应的pi++，让pi指向下一个丑数即可。



```python
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        dp = [0] * (n+1) ##第i个丑数是谁
        dp[1] = 1
        ptr_2 = 1; ptr_3 = 1; ptr_5 = 1
        for i in range(2,n+1):
            next_ugly = min(dp[ptr_2] * 2, dp[ptr_3] * 3, dp[ptr_5] * 5)
            if next_ugly == dp[ptr_2] * 2: ptr_2 += 1
            if next_ugly == dp[ptr_3] * 3: ptr_3 += 1
            if next_ugly == dp[ptr_5] * 5: ptr_5 += 1
            dp[i] = next_ugly
        return dp[-1]
```

【易错点】这里的if不能写成elif，否则会出现重复