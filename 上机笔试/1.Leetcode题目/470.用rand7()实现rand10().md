# 用rand7()实现rand10()

### 拒绝采样

重要的是保证1-10这十个数字**等概率**的出现。一个想法是用两个rand7()相乘，得到相乘矩阵：
​        1	2	3	4	5      6	7
1	1	2	3	4	5	6	7
2	2	4	6	8	10	12	14
3	3	6	9	12	15	18	21
4	4	8	12	16	20	24	28
5	5	10	15	20	25	30	35
6	6	12	18	24	30	36	42
7	7	14	21	28	35	42	49

这个“棋盘”中每个格点出现的概率都是1/49. 那么，每个数字出现的概率为：

![img](https://pic1.zhimg.com/80/v2-89e4b704656dcde8d2233f5063b19ead_1440w.png)

我们可以从中挑选 10个等概率的数即可. 例如[2,3,5,8,14,15,18,20,21,24]出现的概率都是2/49。

```python
class Solution:
    def rand10(self):
        """
        :rtype: int
        """
        accept_num = [2,3,5,8,14,15,18,20,21,24]
        seven_to_ten = {}
        for i in range(len(accept_num)):
            seven_to_ten[accept_num[i]] = i+1 ##构造accept_num->[1~10]的哈希映射
        
        while True:
            num = rand7()*rand7()
            if num in accept_num: ##是这些数之一
                return seven_to_ten[num]
```

为了尽量减少rand7()的调用，我们需要增加随机数被accept的概率。上面这种方法，只有随机数落在[2,3,5,8,14,15,18,20,21,24]才会被accept，效率很低。所以，可以把两个rand7()看成一个“棋盘”，生成1~49，然后按行按列写入1-10.

![微信图片_20210905012406.jpg](https://pic.leetcode-cn.com/1630776258-UNMORj-%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210905012406.jpg)

每个格点对应的数字为`(i-1)*7+j`, 模10+1之后即得到1~10的数字。

这样，49个数字中有40个都会被接受，每次接受的概率为40/49. 如果一直随机下去，直到接受为止，随机的次数的期望是什么呢？其实，这是一个p = 40/49的几何分布，期望次数为1/p = 49/40. 



#### [478. 在圆内随机生成点](https://leetcode-cn.com/problems/generate-random-point-in-a-circle/)

给定圆的半径和圆心的位置，实现函数 `randPoint` ，在圆中产生均匀随机点。

也是采用拒绝采样的思想，我们使用一个边长为 2R 的正方形覆盖住圆 C，并在正方形内随机生成点，若该点落在圆内，我们就返回这个点，否则我们拒绝这个点，重新生成直到新的随机点落在圆内。![pic](https://pic.leetcode-cn.com/Figures/883/squareCircleOverlay.png)

```python
class Solution:

    def __init__(self, radius: float, x_center: float, y_center: float):
        self.radius = radius
        self.x_center = x_center
        self.y_center = y_center


    def randPoint(self) -> List[float]:
        while True:
            xx = random.uniform(self.x_center-self.radius,self.x_center+self.radius)
            yy = random.uniform(self.y_center-self.radius,self.y_center+self.radius)
            if (xx-self.x_center)**2+(yy-self.y_center)**2 <= self.radius**2:
                return [xx,yy]
```

【总结】

- python库中的均匀分布：`random.uniform(left,right)`