# [51. N 皇后](https://leetcode.cn/problems/n-queens/) [八皇后]

难度困难1386

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

 

**示例 1：**



```
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
```



```python
class Solution(object):
    def solveNQueens(self, n):
        """
        :type n: int
        :rtype: List[List[str]]
        """
        self.ans = []
        self.no_diagnoal = []
        self.no_column = []
        self.board_list = []
        def get_board(position,n):
            board = [["." for i in range(n)] for _ in range(n)]
            for i in range(len(position)):
                board[i][position[i]] = "Q"
            board = ["".join(_) for _ in board]
            return board

        def diagonal(i,j,n):
            diag = []
            x = i; y = j
            while x >= 0 and y >= 0:
                x -= 1; y -= 1
                diag.append((x,y))
            x = i; y = j
            while x < n and y < n:
                x += 1; y += 1
                diag.append((x,y))
            x = i; y = j
            while x < n and y >= 0:
                x += 1; y -= 1
                diag.append((x,y))
            x = i; y = j
            while x >= 0 and y < n:
                x -= 1; y += 1
                diag.append((x,y))
            return diag

        def dfs(i,n): ##正在摆第i个皇后，总共有n个
            if i == n:
                self.board_list.append(get_board(self.ans,n))
                return 
            for j in range(n):
                
                if j not in self.no_column and (i,j) not in self.no_diagnoal:
                    self.ans.append(j)
                    self.no_column.append(j)
                    no_diag = diagonal(i,j,n)
                    for item in no_diag:
                        self.no_diagnoal.append(item)
                    dfs(i+1,n)
                    for _ in range(len(no_diag)):
                        self.no_diagnoal.pop()  ###易错！不能直接把list赋值成tmp，这样会出现浅拷贝问题！！
                    self.no_column.pop()
                    self.ans.pop()
        dfs(0,n)
        return self.board_list
```

