#### [743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/) [dijkstra]

难度中等

有 `n` 个网络节点，标记为 `1` 到 `n`。

给你一个列表 `times`，表示信号经过 **有向** 边的传递时间。 `times[i] = (ui, vi, wi)`，其中 `ui` 是源节点，`vi` 是目标节点， `wi` 是一个信号从源节点传递到目标节点的时间。

现在，从某个节点 `K` 发出一个信号。需要多久才能使**所有节点**都收到信号？如果不能使所有节点收到信号，返回 `-1` 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png)

```
输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
输出：2
```

解：**单源最短路**问题 -> Dijkstra算法

```python
class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        graph = [[] for _ in range(n)] ### 邻接表
        for item in times:
            source = item[0]; target = item[1]; weight = item[2]
            graph[source-1].append((target-1,weight))

        dist = [1000000000] * n ###从单源到每个节点的最短路径
        dist[k-1] = 0 ##起始点设为0
        heap = [(0,k-1)] ##小根堆，一开始堆中只有一个起点
        
        while len(heap):
            top = heapq.heappop(heap) ##弹出堆顶
            top_node = top[1]; top_dist = top[0]
            for neighbor in graph[top_node]: ###对于堆顶的所有邻居
                node_neighbor = neighbor[0]; weight = neighbor[1]
                if top_dist+weight < dist[node_neighbor]: ###找到了一条更短的路了！
                    dist[node_neighbor] = top_dist+weight ##如是更新
                    heapq.heappush(heap,(top_dist+weight,node_neighbor)) ###push进堆
        return max(dist) if max(dist) != 1000000000 else -1
```

