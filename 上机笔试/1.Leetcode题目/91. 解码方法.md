#### [91. 解码方法](https://leetcode.cn/problems/decode-ways/)

难度中等1186

一条包含字母 `A-Z` 的消息通过以下映射进行了 **编码** ：

```
'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
```

要 **解码** 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，`"11106"` 可以映射为：

- `"AAJF"` ，将消息分组为 `(1 1 10 6)`
- `"KJF"` ，将消息分组为 `(11 10 6)`

注意，消息不能分组为  `(1 11 06)` ，因为 `"06"` 不能映射为 `"F"` ，这是由于 `"6"` 和 `"06"` 在映射中并不等价。

给你一个只含数字的 **非空** 字符串 `s` ，请计算并返回 **解码** 方法的 **总数** 。

题目数据保证答案肯定是一个 **32 位** 的整数。

 

**示例 1：**

```
输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
```



题解：

用动态规划

```python
class Solution:
    def numDecodings(self, s: str) -> int:
        
        def is_valid(left,right): ###s[left,right]是否表示一个合法的字符
            if s[left] == "0": return False
            return int(s[left:right+1]) >= 1 and int(s[left:right+1]) <= 26
        
        dp = [0] * len(s)
        if s[0] != "0": dp[0] = 1
        for i in range(1,len(s)):
            if is_valid(i,i): dp[i] += dp[i-1]
            if is_valid(i-1,i): 
                if i >= 2:dp[i] += dp[i-2]
                else: dp[i] += 1
        return dp[-1]
```

