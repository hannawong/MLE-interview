# 专题 - 位运算



### 【典型题1】n & (n-1)是把n的二进制位中最低位的1变成0之后的结果 

#### 统计二进制数中1的个数

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数。

解法：

最简单的方法就是每一位都用位运算（通过mask）判断是否为1，只需要统计32次。复杂度O(n), n为位数。当然这里n = 32，所以可以理解为O(1).

```python
    def hammingWeight(self, n: int) -> int:
        cnt = 0
        for i in range(32):
            mask = 1 << i
            digit = (n & mask) >> i
            cnt += digit
        return cnt
```

**进阶：**O(logn)方法。

观察这个运算：**n & (n−1)，其运算结果恰为把 n 的二进制位中的最低位的 1 变为 0 之后的结果。**所以，我们只需要让 n 不停的 赋值为n & (n-1), 直到n为0.

```python
    def hammingWeight(self, n: int) -> int:
        cnt = 0
        while n:
            n = n & (n-1)
            cnt += 1
        return cnt
```



#### [231. 2 的幂](https://leetcode.cn/problems/power-of-two/)

难度简单496

给你一个整数 `n`，请你判断该整数是否是 2 的幂次方。如果是，返回 `true` ；否则，返回 `false` 。

如果存在一个整数 `x` 使得 `n == 2**x` ，则认为 `n` 是 2 的幂次方。

**示例 1：**

```
输入：n = 1
输出：true
解释：2^0 = 1
```

题解：如果一个数是2的幂，那么它一定只有一位为1！这样，我们就可以利用 `n & (n-1)` 是把n的最低位置零这个性质，如果`n & (n-1) == 0`, 那么就说明n一定是2的幂。

 题解：

```python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and n & (n-1) == 0
```

#### [342. 4的幂](https://leetcode.cn/problems/power-of-four/)

难度简单300

给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 `true` ；否则，返回 `false` 。

整数 `n` 是 4 的幂次方需满足：存在整数 `x` 使得 `n == 4^x`

**示例 1：**

```
输入：n = 16
输出：true
```

题解：先判断是否是2的幂（即，二进制表示只有一位是1）；然后，在判断是否是4的幂（即，这唯一的一个`1`不能出现在1,3,5,7,9... 位）

这个判断可以用`n&0xaaaaaaaa`表示，因为`0xaaaaaaaa = 1010 1010 1010 1010 1010 1010 1010 1010`, 正好对应所有的奇数位。

```python
class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        return n > 0 and n & (n-1) == 0 and n & 0xaaaaaaaa == 0
```



#### [326. 3 的幂](https://leetcode.cn/problems/power-of-three/) （无法用二进制来完成）

难度简单254

给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 `true` ；否则，返回 `false` 。

整数 `n` 是 3 的幂次方需满足：存在整数 `x` 使得 `n == 3^x`



题解：本题就没有上面两种做法那么好的性质了，只能用“笨办法”来完成：即，每次都看模3的余数是否为0，然后除以3继续迭代。

```python
class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        if n <= 0:
            return False
        while n > 1:
            digit = n % 3
            n = n // 3
            if digit != 0:
                return False
        return True
```

另外，还有一种取巧的做法。由于3是质数，那么任何3的倍数都可以被 3 ** 19 整除，所以用这个来判断可以达到复杂度O(1). 

```python
class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        return n > 0 and 3**19 % n == 0
```



## IP地址转换

##### **输入描述:**

```
输入 
1 输入IP地址
2 输入10进制型的IP地址
```

##### **输出描述:**

```
输出
1 输出转换成10进制的IP地址
2 输出转换后的IP地址
```

示例1

###### 输入

```
10.0.3.193
167969729
```

###### 输出

```
167773121
10.3.3.193
```

代码：

```python
def ip2num(string):
    string_list = string.split(".")
    ans = 0
    ans += int(string_list[0]) << 24
    ans += int(string_list[1]) << 16
    ans += int(string_list[2]) << 8
    ans += int(string_list[3])
    return ans

def num2ip(num):
    mask = 2 ** 8 - 1
    ip1 = num & mask
    ip2 = (num & (mask << 8)) >> 8
    ip3 = (num & (mask << 16)) >> 16
    ip4 = (num & (mask << 24)) >> 24
    ans = str(ip4)+"."+str(ip3)+"."+str(ip2)+"."+str(ip1)
    return ans
while True:
    try:
        inp = input()
        print(ip2num(inp))
        inp2 = input()
        print(num2ip(int(inp2)))
    except:
        break
```

易错点是要注意位运算的优先级，该写括号的地方一定要写好括号。例如：

`ip2 = (num & (mask << 8)) >> 8` 如果写成 `ip2 = num & (mask << 8) >> 8`就是错误的！



#### [剑指 Offer 65. 不用加减乘除做加法](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)

难度简单301

写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。

 

**示例:**

```
输入: a = 1, b = 1
输出: 2
```

题解：两个数的**异或**值就是**不带进位的加法**；两个数的且 就是进位。将二者相加就可以。

```python
class Solution {
public:
    int add(int a, int b) {
        if(b == 0) return a;
        if (a==0) return b;
        return add(a^b, (unsigned int)(a&b) << 1);
    }
};
```

这里要注意的一点是，c++中不支持负数的位移，所以要先转换成(unsigned int). 



----

## 负数补码表示

7的二进制是 0111，那么-7的二进制是多少呢？在计算机中，负数以其正值的**补码**形式表达。

- 原码：一个整数，按照绝对值大小转换成的二进制数，称为原码。比如 `00000000 00000000 00000000 00000111` 是 7的 原码。
- 反码：将二进制数**按位取反**，所得的新二进制数称为原二进制数的反码。
  比如：将00000000 00000000 00000000 00000111每一位取反，得11111111 11111111 11111111 11111000。
- 补码：反码加1称为补码。
  补码为：11111111 11111111 11111111 11111000 + 1 = 11111111 11111111 11111111 11111001

所以，-7 在计算机中表达为：11111111 11111111 11111111 11111001

反码转为原码：减1取反。