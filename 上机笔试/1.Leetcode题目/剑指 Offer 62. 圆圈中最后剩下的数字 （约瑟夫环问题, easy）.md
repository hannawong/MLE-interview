#### [剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/) （约瑟夫环问题, easy）

> 这个问题是以弗拉维奥·约瑟夫命名的，他是1世纪的一名犹太历史学家。他在自己的日记中写道，他和他的40个战友被罗马军队包围在洞中。他们讨论是自杀还是被俘，最终决定自杀，并以抽签的方式决定谁杀掉谁。约瑟夫斯和另外一个人是最后两个留下的人。约瑟夫斯说服了那个人，他们将向罗马军队投降，不再自杀。约瑟夫斯把他的存活归因于运气或天意，他不知道是哪一个。
>



0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

 

**示例 1：**

```
输入: n = 5, m = 3
输出: 3
```

题解：

模拟整个删除过程最直观，即构建一个长度为 n 的链表，每轮删除第 m 个节点，直至链表长度为 1 时结束，返回最后剩余节点的值即可。

但是模拟法需要循环删除 n - 1 轮，每轮在链表中寻找删除节点需要 m 次访问操作（链表线性遍历），因此总体时间复杂度为 O(nm)。

其实，大名鼎鼎的约瑟夫环问题当然是有数学解法的啦~其重点在于想清楚递推关系。这个递推关系真的很难想，不知道为什么这是简单题...

「n, m问题」：数字环为 0, 1, 2, ..., n - 1解为 f(n) ；
「n-1, m问题」：数字环为 0, 1, 2, ..., n - 2，解为 f(n-1)；
以此类推……



对于[n,m问题]，我们第一个删除的是（m-1）% n; 剩下的序列是从(m)%n开始的。记m%n = t的话，那么剩下的序列为：t,t+1,t+2,...,0,1,...,t−3,t−2

观察数字序号对应关系：

![img](https://pic3.zhimg.com/80/v2-97f33217f71e20a4c7a9cf715a785a2f_1440w.png)

可以找到对应关系：x->(x+t)%n.

所以，假设我们知道[n-1,m]问题最后剩下的元素编号f(n-1), 那么[n,m]问题删除后对应的元素编号为

**f(n) = (f(n-1)+t) % n = (f(n-1)+m%n) %n**

这就是递推公式！其中，f(n)是[n,m]问题最后剩下的元素，f(n-1)是[n-1,m]问题最后剩下的元素。按这个写代码就很简单了。

```python
class Solution:
    def lastRemaining(self, n: int, m: int) -> int:
        dp = [0]*(n+1)
        for i in range(1,n+1):
            dp[i] = (dp[i-1]+m%i) % i
        return dp[-1] 
```



